# Домашнее задание к занятию "Базы данных, их типы"

**SYSDB-46 / Ларионов Сергей**

---

### Задание 1: СУБД

#### 1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков

Для этой задачи лучше всего подойдёт реляционная СУБД (RDBMS), такая как PostgreSQL или MySQL. Почему? Реляционные базы обеспечивают строгую структуру данных с помощью таблиц, связей и ACID-свойств (атомарность, согласованность, изоляция, долговечность), что гарантирует целостность данных. Это идеально для финансовых расчётов, где ошибки могут привести к серьёзным последствиям, и для аналитических отчётов с использованием SQL-запросов. Они также поддерживают транзакции, что важно для прогнозирования рисков на основе исторических данных.

#### 1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

Для ускорения хеширования можно использовать API криптографических библиотек, таких как OpenSSL API (например, функции EVP_Digest для SHA-256) или встроенные в языки программирования (например, hashlib в Python или MessageDigest в Java). Эти API оптимизированы для аппаратного ускорения (если поддерживается CPU) и позволяют обрабатывать данные быстрее, чем самописные реализации. Также можно рассмотреть GPU-ускорение через CUDA или OpenCL для массовых операций.

#### 1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам

Для лендингов (где данные часто неструктурированы и требуют быстрого чтения/записи) лучше использовать NoSQL СУБД, такую как MongoDB (документо-ориентированная), так как она гибкая и позволяет хранить данные в формате JSON без строгой схемы. Для CRM (где нужны связи между клиентами, сделками и историей) подойдёт реляционная СУБД, например, PostgreSQL, для обеспечения связей и целостности. Обе должны быть быстрыми: NoSQL для масштабируемости, SQL для аналитики.

#### 1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

Да, можно использовать одну СУБД — гибридную или многомодельную, такую как PostgreSQL с расширением для JSON (например, JSONB для хранения неструктурированных данных лендингов) или ArangoDB (мультимодельная, поддерживающая документы и графы). Реализация: PostgreSQL как основа для CRM с реляционными таблицами, а JSONB для гибких данных лендингов. Это позволит избежать дублирования и упростить интеграцию.

#### 1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании

Здесь подойдёт реляционная СУБД с простой схемой, например, SQLite или MySQL, так как данные структурированы (правила, нормы, материалы) и требуют понятной иерархии. Она обеспечивает лёгкость в навигации и управлении через SQL-запросы, без излишней сложности.

#### 1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

Да, можно использовать PostgreSQL из задачи 1.1 (бюджетирование), так как она уже обеспечивает целостность и структуру. Реализация: создать отдельную схему или базу данных внутри PostgreSQL для данных контроля качества, с таблицами для норм, правил и материалов. Это позволит интегрировать с существующими данными (например, связать с проектами) и избежать дополнительных систем.

#### 1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов

Лучше всего графовая СУБД, такая как Neo4j, так как она отлично работает со связями (маршруты, объекты, курьеры как узлы и рёбра). Она позволяет быстро строить графы для оптимизации маршрутов и распределения ресурсов, с поддержкой сложных запросов на Cypher.

#### 1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?
Можно подключить отдел закупок к Neo4j, расширив граф для включения поставщиков, заказов и инвентаря. Если данные закупок более табличные (списки товаров, цены), лучше использовать связку: Neo4j для логистики и реляционную СУБД (например, PostgreSQL) для закупок, с интеграцией через API или ETL-процессы для синхронизации данных.

#### 1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

Да, можно использовать мультимодельную СУБД, такую как ArangoDB или OrientDB, которая поддерживает реляционные, документные и графовые модели. Она справится с бюджетированием (реляционная часть), лендингами/CRM (документная), контролем качества (реляционная), логистикой (графовая). Это упростит архитектуру, снизит затраты на интеграцию и обеспечит гибкость.

---

## Задание 2: Транзакции

#### 2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

Инициирование транзакции: Пользователь вводит данные (номер телефона, сумму) в приложение или на сайте оператора, и система начинает транзакцию, проверяя валидность данных.
Блокировка ресурсов: Система блокирует счёт пользователя (или карту) и временно резервирует средства, чтобы избежать двойного списания.
Проверка баланса и авторизация: Проверяется достаточность средств на счёте/карте и проводится авторизация через платёжный шлюз (например, Visa или банковский API).
Списание средств: Средства списываются со счёта пользователя и переводятся на промежуточный счёт оператора связи.
Зачисление на баланс телефона: Оператор связи получает подтверждение и зачисляет сумму на баланс телефона, обновляя базу данных.
Подтверждение и фиксация: Система отправляет подтверждение пользователю (SMS или уведомление), и транзакция фиксируется (commit) с логированием для аудита.

#### 2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

В случае автоплатежа шаги аналогичны, но автоматизированы: система периодически (по расписанию) проверяет условия (например, баланс ниже порога), инициирует транзакцию без участия пользователя, блокирует ресурсы, проводит авторизацию, списывает и зачисляет средства, затем подтверждает через уведомление. Дополнительно: если автоплатёж не удался (недостаточно средств), система может повторить попытку или уведомить пользователя о необходимости ручного вмешательства.

---

## Задание 3: SQL vs NoSQL

#### 3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.

Строгая структура и целостность: SQL-системы обеспечивают ACID-транзакции, что гарантирует согласованность данных и предотвращает ошибки в критических приложениях.
Мощные запросы и аналитика: SQL позволяет выполнять сложные JOIN-запросы, агрегации и отчёты, идеально для бизнес-аналитики.
Стандартизация: SQL — стандартный язык, что облегчает обучение, переносимость и интеграцию с другими системами.
Безопасность и контроль доступа: Реляционные СУБД имеют встроенные механизмы ролей, разрешений и аудита для защиты данных.
Оптимизация производительности: С индексами, оптимизаторами запросов и нормализацией SQL-системы эффективны для предсказуемых нагрузок и сложных связей.

#### 3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

NewSQL сочетает преимущества SQL (ACID, SQL-запросы) с масштабируемостью NoSQL. Преимущества перед традиционным SQL: лучшая горизонтальная масштабируемость и производительность на больших данных без потери транзакций. Перед NoSQL: строгая согласованность и поддержка сложных запросов без необходимости в дополнительных инструментах. В целом, NewSQL (например, CockroachDB) обеспечивает гибкость, скорость и надёжность для современных приложений, снижая компромиссы между моделями.

---

## Задание 4. Кластеры

Для обработки огромного количества данных на 1000 машинах критерием выбора типа СУБД будет масштабируемость и тип нагрузки: если данные структурированы и требуют транзакций (например, аналитика), подойдёт NewSQL или распределённая реляционная СУБД (как Google Spanner). Если данные неструктурированы и нужны быстрые чтения/записи, то NoSQL (как Cassandra). Лучшая модель распределённых вычислений — MapReduce (как в Hadoop) или Apache Spark, так как они позволяют параллельно обрабатывать данные на кластере, распределяя задачи по узлам, обеспечивая отказоустойчивость и балансировку нагрузки. Почему? Они оптимизированы для big data, поддерживают fault tolerance и масштабирование до тысяч машин, минимизируя время вычислений через параллелизм. 

---